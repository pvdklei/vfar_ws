\documentclass{article}

\usepackage[a4paper,margin=1in]{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{float}
\usepackage{graphicx}
\begin{document}

\title{
    \textbf{Lab Project 1 : Line Following}\\
}
\author{
    Mara-Iuliana Dragomir (15729702) \and
    Rick Haakman (13206141)
}
\date{\today}

% ==================== DOCUMENT BEGINS ====================


\maketitle

\section{Introduction}
This report designs, implements, and evaluates a line detection pipeline that identifies a line of ceiling lights from a forward-facing camera on the UGV Rover running with ROS 2 Humble.


\section{Session 1 line detection}

% image -> grayscale -> binarize by threshold 250 -> dilate once -> canny Edge (I think no matter what threshold values I use it's the same since it's a binary image?) -> houghlines -> display the lines over the original image
% \\ \\
\subsection{The line detection pipline}
The following steps summarize the implemented line detection pipeline.
The pipeline starts with obtaining an image from the camera on the rover, obtained by subscribing to the \textit{/image$\_$raw topic}.
Then, the image is turned to grayscale to simplify processing, followed by binarization to remove background information with a threshold of 251.
This high threshold is chosen, because the ceiling lights, which the rover has to follow, emit nearly white light.
The ceiling lights are noisy lines with some gaps, so dilation is then applied to connect them. 
After pre-processing, Canny edge detection is applied to the image.
Finally, Hough Line Transform is applied, using OpenCV's \textit{HoughLinesP} function, to extract lines from the detected edges.
\textit{HoughLinesP} was used over the standard \textit{HoughLines}, due to its higher computational efficiency and suitability for real-time inference.

\subsection{Performance on five frames}
Figure \ref{fig:lines_v1} shows five different detection results using this pipeline, displaying the original images beside the detected lines by our implementation. The third image column concerns Section 2.4 which compares Canny with a different edge detection algorithm.

\begin{figure}
    \centering
    \includegraphics[scale=0.8]{images/lines_v1_1.png} \\
    \includegraphics[scale=0.8]{images/lines_v1_2.png} \\
    \includegraphics[scale=0.8]{images/lines_v1_3.png} \\
    \includegraphics[scale=0.8]{images/lines_v1_4.png} \\
    \includegraphics[scale=0.8]{images/lines_v1_5.png} \\
    \caption{Line detection pipeline results for 5 examples, comparing the plain images with Canny and Laplacian line detectors.}
    \label{fig:lines_v1}
\end{figure}


\subsection{Performance on a ROS bag file}
The pipeline was applied to a ROS bag file containing a video of a rover driving in a straight line on the field in the robolab in LAB42. 
In the video, the ceiling lights are clearly visible.

Figure \ref{fig:early_frames} shows three frames with their detected lines.
The first five frames perform shockingly bad, with some non existent diagonal lines, visible in the top image of the Figure. 
This is likely caused by overexposure at the start of the recording, since from frame 6 onward, lighting conditions stabilize and such false detections disappear.
The consistency of line tracking over time remains an issue.
For example, the middle image of Figure \ref{fig:early_frames} clearly detects the ceiling lights, however, in the next frame, the center right ceiling light is no longer detected.
Another limitation of the pipeline is that each ceiling light is detected as two thin lines, instead of one thick line.

\subsection{A more effective line detection algorithm}
As an alternative to the Canny edge detector, we decided to experiment with a different algorithm, namely the Laplacian edge detector. This method assumes that areas of high intensity changes are associated with edges, therefore it aims to highlight these areas. As its name implies, this method is based on the second order derivative of image intensity, unlike directional gradient methods like Canny or Sobel. In implementation, we simply replaced the Canny edge function with Laplacian from OpenCV, the rest of the pipeline remaining the same. Figure \ref{fig:lines_v1} compares the qualitative results of both Canny and Laplacian.



\begin{figure}
    \centering
    \includegraphics[scale=0.5]{images/frame_00004.png}
    \includegraphics[scale=0.5]{images/frame_00302.png}
    \includegraphics[scale=0.5]{images/frame_00303.png}
    \caption{Line detection on frames from a rosbag.}
    \label{fig:early_frames}
\end{figure}

 

\section{Session 2 line following}
This session is theoretical and not actually implemented.

\subsection{The line following pipeline}
The following steps summarize the line following pipeline.
The pipeline starts with obtaining lines from the line detection pipeline.
Each line is represented by the the x and y coordinates of the start and end points. 
Since the detector gives multiple lines, it is necessary to select a single line to follow.
Without filtering to a single line, the rover does not know which line to follow and will drive uncontrollable, constantly choosing a different line to follow. 
The line to follow is the one above the rover.
The selected line has an x coordinate close to the center of the image, while the y coordinate lies near the top of the image.
Next, to let the rover drive, the \textit{Twist} module is used.

\subsection{Line following with and without rectified images}
Figure \ref{fig:lines_v1} shows rectified images and Figure \ref{fig:early_frames} shows non rectified images with positive radial distortion.
The improvement in image quality is significant, in the first Figure straight lines are obviously curved, whereas in the second Figure it is difficult to note that the image is still slightly curved.

\subsection{ Solving remaining challenging problem}
TODO % maybe something about the 2 lines per light, but i dunno how
\subsection{Using OAK-D camera for this task} % also dunno how
TODO

\section{Conclusion}
This report designed and implemented a line detection pipeline for a UGV Rover. Using grayscaling, followed by binarization, dilation, Canny edge detection and Hough Line Transform proved to be an effective method for detecting ceiling lines.

A line following pipeline was also proposed by filtering the detected lines based on central x and a upper y coordinates, and using Twist to control the rover.

\end{document}
